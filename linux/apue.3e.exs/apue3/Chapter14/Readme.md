1. Write a test program that illustrates your system’s behavior when a process
   is blocked while trying to write lock a range of a file and additional
   read-lock requests are made. Is the process requesting a write lock starved
   by the processes read locking the file?

   Here's the program (also in `exercise_1.c`):

   ```c
   #include <fcntl.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <sys/stat.h>
   #include <sys/types.h>
   #include <sys/wait.h>
   #include <time.h>
   #include <unistd.h>
   
   static int
   lock(const int fd, const int lock_type)
   {
   	struct flock fl = {};
   
   	fl.l_type = lock_type;
   	fl.l_whence = SEEK_SET;
   	fl.l_start = 0;
   	fl.l_len = 0; /* lock entire file */
   
   	if (fcntl(fd, F_SETLKW, &fl) < 0) {
   		perror("fcntl");
   		return 1;
   	}
   
   	return 0;
   }
   
   static int
   unlock(const int fd)
   {
   	struct flock fl = {};
   
   	fl.l_type = F_UNLCK;
   
   	if (fcntl(fd, F_SETLKW, &fl) < 0) {
   		perror("fcntl");
   		return 1;
   	}
   
   	return 0;
   }
   
   static int
   reader(const char* const filename, const int reader_num, const int sleep_time)
   {
   	const int fd = open(filename, O_RDONLY);
   	int i;
   
   	if (fd < 0) {
   		perror("open");
   		return 1;
   	}
   
   	fprintf(stderr, "\nreader %d attempting to acquire read lock", reader_num);
   	lock(fd, F_RDLCK);
   	fprintf(stderr, "\nreader %d acquired read lock", reader_num);
   
   	sleep(sleep_time);
   
   	unlock(fd);
   	fprintf(stderr, "\nreader %d unlocked", reader_num);
   
   	return 0;
   }
   
   static int
   writer(const char* const filename, const int sleep_time)
   {
   	struct stat statbuf = {};
   
   	if (stat(filename, &statbuf) < 0) {
   		perror("stat");
   		return 1;
   	}
   
   	const int fd = open(filename, O_WRONLY);
   	if (fd < 0) {
   		perror("open");
   		return 1;
   	}
   
   	fprintf(stderr, "\nwriter attempting to acquire write lock");
   	lock(fd, F_WRLCK);
   	fprintf(stderr, "\nwriter acquired write lock");
   
   	sleep(sleep_time);
   
   	unlock(fd);
   	fprintf(stderr, "\nwriter unlocked");
   
   	return 0;
   }
   
   int
   main(const int argc, const char* const argv[])
   {
   	if (argc < 2) {
   		fprintf(stderr, "usage: %s <filename>\n", argv[0]);
   		return 1;
   	}
   
   	const char* const filename = argv[1];
   
   	srand(time(NULL));
   
   	/* Child1 will get and hold a read lock */
   	const pid_t child1 = fork();
   	if (child1 < 0) {
   		perror("fork");
   		return 1;
   	} else if (child1 == 0) {
   		return reader(filename, 1, 15);
   	}
   
   	/* Make sure child1 starts and gets the write lock */
   	sleep(5);
   
   	/* Child 2 will try to get a write lock while child1 still holds
   	   the read lock */
   	const pid_t child2 = fork();
   	if (child2 < 0) {
   		perror("fork");
   		return 1;
   	} else if (child2 == 0) {
   		return writer(filename, 2);
   	}
   
   	/* Make sure child2 starts and blocks on the write lock */
   	sleep(5);
   
   	/* Child3 will start with child2 blocked trying to acquire the
   	   write lock.  Will it prevent child2 from running? */
   	const pid_t child3 = fork();
   	if (child3 < 0) {
   		perror("fork");
   		return 1;
   	} else if (child3 == 0) {
   		return reader(filename, 2, 20);
   	}
   
   	/* Wait for and clean up all the children */
   	wait(NULL);
   	wait(NULL);
   	wait(NULL);
   
   	printf("\n");
   	return 0;
   }
   ```

   _Is the process requesting a write lock starved by the processes read
   locking the file?_

   Yes, additional readers will continue to block the writer.  Here's a sample
   of the output generated by the program:

   ```
   $ ./a.out some.file
   
   reader 1 attempting to acquire read lock
   reader 1 acquired read lock
   writer attempting to acquire write lock
   reader 2 attempting to acquire read lock
   reader 2 acquired read lock
   reader 1 unlocked
   reader 2 unlocked
   writer acquired write lock
   writer unlocked
   ```

   Note that the writer attempted to acquire the write lock before reader 2
   acquired the read lock, but reader 2 completed before the writer
   successfully acquired the write lock.

2. Take a look at your system’s headers and examine the implementation of
   `select` and the four `FD_` macros.

   ```c
   /* /usr/include/bits/typesizes.h */
   #define __FD_SETSIZE		1024

   /* /usr/include/sys/select.h */
   #define __NFDBITS	(8 * (int) sizeof (__fd_mask))

   typedef struct
   {
       /* XPG4.2 requires this member name.  Otherwise avoid the name
          from the global namespace.  */
   #ifdef __USE_XOPEN
       __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
   # define __FDS_BITS(set) ((set)->fds_bits)
   #else
       __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
   # define __FDS_BITS(set) ((set)->__fds_bits)
   #endif
   } fd_set;

   extern int select (int __nfds, fd_set *__restrict __readfds,
                      fd_set *__restrict __writefds,
                      fd_set *__restrict __exceptfds,
                      struct timeval *__restrict __timeout);

   /* /usr/include/bits/select.h */
   #define FD_SET(fd, fdsetp)      __FD_SET (fd, fdsetp)
   #define FD_CLR(fd, fdsetp)      __FD_CLR (fd, fdsetp)
   #define FD_ISSET(fd, fdsetp)    __FD_ISSET (fd, fdsetp)
   #define FD_ZERO(fdsetp)         __FD_ZERO (fdsetp)

   # define __FD_ZERO(fdsp) \
     do {                                                                        \
       int __d0, __d1;                                                           \
       __asm__ __volatile__ ("cld; rep; " __FD_ZERO_STOS                         \
                             : "=c" (__d0), "=D" (__d1)                          \
                             : "a" (0), "0" (sizeof (fd_set)                     \
                                             / sizeof (__fd_mask)),              \
                               "1" (&__FDS_BITS (fdsp)[0])                       \
                             : "memory");                                        \
     } while (0)
   #define __FD_SET(d, set) \
     ((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))
   #define __FD_CLR(d, set) \
     ((void) (__FDS_BITS (set)[__FD_ELT (d)] &= ~__FD_MASK (d)))
   #define __FD_ISSET(d, set) \
     ((__FDS_BITS (set)[__FD_ELT (d)] & __FD_MASK (d)) != 0)
   ```
   
3. The system headers usually have a built-in limit on the maximum number of
   descriptors that the `fd_set` data type can handle. Assume that we need to
   increase this limit to handle up to 2,048 descriptors. How can we do this?

   We could change the value of the `__FD_SETSIZE` macro, however,
   `select` and friends are system calls, so there's a kernel-side to the
   implementation.  The kernel has the same size limits:

   ```c
   /* /usr/src/linux/include/uapi/linux/posix_types.h */
   #undef __FD_SETSIZE
   #define __FD_SETSIZE    1024
   
   typedef struct {
           unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
   } __kernel_fd_set;
   ```

   We'd have to change the size there as well and recompile the kernel.

4. Compare the functions provided for signal sets (Section 10.11) and the
   `fd_set` descriptor sets. Also compare the implementation of the two on
   your system.

   The functions provided for signal sets:

   ```c
   int sigemptyset(sigset_t *set);
   int sigfillset(sigset_t *set);
   int sigaddset(sigset_t *set, int signo);
   int sigdelset(sigset_t *set, int signo);
   int sigismember(const sigset_t *set, int signo);
   ```

   The `fd_set` descriptor sets:

   ```c
   void FD_CLR(int fd, fd_set *set);
   int  FD_ISSET(int fd, fd_set *set);
   void FD_SET(int fd, fd_set *set);
   void FD_ZERO(fd_set *set);
   ```

   Here are the similarities:
   * `sigemptyset` is similar to `FD_ZERO`, both empty the set.
   * `sigaddset` is similar to `FD_SET`, both add an element to the set.
   * `sigdelset` is similar to `FD_CLR`, both remove an element from the set.
   * `sigismember` is similar to `FD_ISSET`, both test to see if an element
     is in the set.

   There is no `FD_` API that is similar to `sigfillset`.  We often want
   to perform operations on all signals, but we don't often (ever?) want
   to do something with all file descriptors, most of which are probably
   not open.

   The signal set APIs are part of glibc.  Here's the definition of the
   `sigset_t` type:

   ```c
   #ifdef __USE_POSIX199309
   union sigval
   {
   	int sival_int;
   	void *sival_ptr;
   };
   
   typedef union sigval __sigval_t;
   #else
   union __sigval
   {
   	int __sival_int;
   	void *__sival_ptr;
   };
   
   typedef union __sigval __sigval_t;
   #endif
   ```
   
   Here's the implementation of `sigaddset`:

   ```c
   int
   sigaddset (sigset_t *set, int signo)
   {
   	if (set == NULL || signo <= 0 || signo >= NSIG
   	    || __is_internal_signal (signo))
   	{
   		__set_errno (EINVAL);
   		return -1;
   	}
   
   	__sigaddset (set, signo);
   	return 0;
   }
   ```

   And here's the implementation of `__sigaddset`:

   ```c
   # define __sigaddset(set, sig)                  \
     (__extension__ ({                             \
       __sigset_t __mask = __sigmask (sig);        \
       *(set) |= __mask;                           \
       0;                                          \
     }))
   ```

   Like the `FD_` macros we looked at earlier, it looks like the fdset API
   uses a bitmap where each bit represents a signal number.

5. Implement the function `sleep_us`, which is similar to `sleep`, but waits
   for a specified number of microseconds. Use either `select` or `poll`.
   Compare this function to the BSD `usleep` function.

   Here's my implementation (see also `exercise_5.c`):

   ```c
   #include <stdio.h>
   #include <sys/select.h>
   
   suseconds_t
   sleep_us(const suseconds_t microseconds)
   {
   	struct timeval timeout = { .tv_usec = microseconds };
   
   	(void) select(0, NULL, NULL, NULL, &timeout);
   
   	return timeout.tv_usec;
   }
   
   static suseconds_t
   seconds_to_microseconds(double seconds)
   {
   	return seconds * 1000000U;
   }
   
   int
   main(void)
   {
   	sleep_us(seconds_to_microseconds(5.25));
   	return 0;
   }
   ```

6. Can you implement the functions `TELL_WAIT`, `TELL_PARENT`, `TELL_CHILD`,
   `WAIT_PARENT`, and `WAIT_CHILD` from Figure 10.24 using advisory record
   locking instead of signals? If so, code and test your implementation.

   Skipping.

7. Determine the capacity of a pipe using nonblocking writes. Compare this
   value with the value of `PIPE_BUF` from Chapter 2.

   The following program (also in `exercise_7.c`) will print the size of a
   pipe buffer:

   ```c
   #include <fcntl.h>
   #include <stdio.h>
   #include <unistd.h>
   
   static int
   make_non_blocking(const int fd)
   {
   	const int flags = fcntl(fd, F_GETFL); 
   	if (flags < 0) {
   		perror("fcntl");
   		return -1;
   	}
   
   	return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
   }
   
   int main(void)
   {
   	int retval = 1;
   	int pipe_fds[2] = {};
   
   	if (pipe(pipe_fds) < 0) {
   		perror("pipe");
   		return 1;
   	}
   
   	// Make the write-end of the pipe non-blocking
   	if (make_non_blocking(pipe_fds[1]) < 0) {
   		goto close_pipe;
   	}
   
   
   	int i;
   	for (i = 0; write(pipe_fds[1], "a", 1) == 1; ++i);
   
   	printf("pipe size: %d\n", i);
   
   	retval = 0;
   
   close_pipe:
   	close(pipe_fds[0]);
   	close(pipe_fds[1]);
   
   	return retval;
   }
   ```

   A sample run:

   ```
   $ ./a.out
   pipe size: 65536
   ```

   The value larger than `PIPE_BUF`:

   ```
   /* /usr/include/linux/limits.h */
   #define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
   ```

   So we can write 65536 bytes, but can write only 4096 bytes at a time with
   atomic guarantees.

8. Rewrite the program in Figure 14.21 to make it a filter: read from the
   standard input and write to the standard output, but use the asynchronous
   I/O interfaces. What must you change to make it work properly? Keep in mind
   that you should get the same results whether the standard output is attached
   to a terminal, a pipe, or a regular file.

   Skipping.

9. Recall Figure 14.23. Determine the break-even point on your system where
   using `writev` is faster than copying the data yourself and using a single
   `write`.

   Skipping.

10. Run the program in Figure 14.27 to copy a file and determine whether the
    last-access time for the input file is updated.

    No, the last-access time of the input file was not modified.  Note,
    however, that the filesystem is mounted (by default) with the `relatime`
    mount option:

    ```
    $ stat source;./a.out source dest; stat source
      File: source
      Size: 1073741824	Blocks: 2097160    IO Block: 4096   regular file
    Device: 800h/2048d	Inode: 437128      Links: 1
    Access: (0640/-rw-r-----)  Uid: ( 1000/ user)   Gid: ( 1000/ group)
    Access: 2019-05-03 20:17:14.759053945 -0400
    Modify: 2019-05-03 20:04:28.085720632 -0400
    Change: 2019-05-03 20:04:28.085720632 -0400
     Birth: -
      File: source
      Size: 1073741824	Blocks: 2097160    IO Block: 4096   regular file
    Device: 800h/2048d	Inode: 437128      Links: 1
    Access: (0640/-rw-r-----)  Uid: ( 1000/ user)   Gid: ( 1000/ group)
    Access: 2019-05-03 20:17:14.759053945 -0400
    Modify: 2019-05-03 20:04:28.085720632 -0400
    Change: 2019-05-03 20:04:28.085720632 -0400
     Birth: -
    ```

    According to `man mount`:

    ```
    relatime
           Update inode access times relative to modify or change time.  Access
           time  is  only  updated if the previous access time was earlier than
           the current modify or change time.   (Similar  to  noatime,  but  it
           doesn't break mutt or other applications that need to know if a file
           has been read since the last time it was modified.)

           Since Linux 2.6.30, the kernel defaults to the behavior provided  by
           this  option  (unless  noatime  was  specified), and the strictatime
           option is required to obtain traditional  semantics.   In  addition,
           since Linux 2.6.30, the file's last access time is always updated if
           it is more than 1 day old.
    ```

    If I remount the filesytem with `strictatime`:

    ```
    $ sudo mount -oremount,strictatime /
    ```

    With that change in place, the program does update the atime:

    ```
    $ stat source; ./a.out source dest; stat source
      File: source
      Size: 1073741824	Blocks: 2097160    IO Block: 4096   regular file
    Device: 800h/2048d	Inode: 437128      Links: 1
    Access: (0640/-rw-r-----)  Uid: ( 1000/ adalton)   Gid: ( 1000/ adalton)
    Access: 2019-05-03 20:43:16.982387247 -0400
    Modify: 2019-05-03 20:04:28.085720632 -0400
    Change: 2019-05-03 20:04:28.085720632 -0400
     Birth: -
      File: source
      Size: 1073741824	Blocks: 2097160    IO Block: 4096   regular file
    Device: 800h/2048d	Inode: 437128      Links: 1
    Access: (0640/-rw-r-----)  Uid: ( 1000/ adalton)   Gid: ( 1000/ adalton)
    Access: 2019-05-03 20:43:35.599053913 -0400
    Modify: 2019-05-03 20:04:28.085720632 -0400
    Change: 2019-05-03 20:04:28.085720632 -0400
     Birth: -
    ```

11. In the program from Figure 14.27, `close` the input file after calling
    `mmap` to verify that closing the descriptor does not invalidate the
    memory-mapped I/O.

    Closing the file does not invalidate the memory-mapped I/O.  The program
    is below (an also `exercise_11.c`):

    ```c
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>
    #include <fcntl.h>
    #include <sys/mman.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <unistd.h>
    
    #define FILE_MODE 0644
    #define COPYINCR (1024 * 1024l * 1024)
    
    #define err_sys(fmt, ...) fprintf(stderr, (fmt "\n"), ##__VA_ARGS__)
    #define err_quit(fmt, ...) do { err_sys(fmt, ##__VA_ARGS__); exit(1); } while(0)
    
    int
    main(int argc, char *argv[])
    {
    	int fdin, fdout;
    	void *src, *dst;
    	size_t copysz;
    	struct stat sbuf;
    	off_t fsz = 0;
    
    	/* 1 GB */
    	if (argc != 3)
    		err_quit("usage: %s <fromfile> <tofile>", argv[0]);
    
    	if ((fdin = open(argv[1], O_RDONLY)) < 0)
    		err_sys("can’t open %s for reading", argv[1]);
    
    	if ((fdout = open(argv[2], O_RDWR | O_CREAT | O_TRUNC, FILE_MODE)) < 0)
    		err_sys("can’t creat %s for writing", argv[2]);
    
    	if (fstat(fdin, &sbuf) < 0)         /* need size of input file */
    		err_sys("fstat error");
    
    	if (ftruncate(fdout, sbuf.st_size) < 0) /* set output file size */
    		err_sys("ftruncate error");
    
    	while (fsz < sbuf.st_size) {
    		if ((sbuf.st_size - fsz) > COPYINCR)
    			copysz = COPYINCR;
    		else
    			copysz = sbuf.st_size - fsz;
    
    		if ((src = mmap(0, copysz, PROT_READ, MAP_SHARED,
    		                fdin, fsz)) == MAP_FAILED)
    			err_sys("mmap error for input");
    		close(fdin); /* Added for the exercise */
    		fdin = -1;
    
    		if ((dst = mmap(0, copysz, PROT_READ | PROT_WRITE,
    		                MAP_SHARED, fdout, fsz)) == MAP_FAILED)
    			err_sys("mmap error for output");
    		close(fdout); /* Added for the exercise */
    		fdout = -1;
    
    		memcpy(dst, src, copysz); /* does the file copy */
    		munmap(src, copysz);
    		munmap(dst, copysz);
    
    		fsz += copysz;
    	}
    	exit(0); 
    }
    ```
